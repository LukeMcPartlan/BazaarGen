<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bazaar Items Browser - View Community Creations | BazaarGen</title>
    
    <!-- External Libraries with fallback -->
    <script src="https://unpkg.com/@supabase/supabase-js@2" onload="console.log('Supabase CDN 1 loaded successfully')" onerror="console.error('Supabase CDN 1 failed, trying fallback'); loadSupabaseFallback()"></script>
    
    <script>
        // Fallback CDN loader
        function loadSupabaseFallback() {
            console.log('Loading Supabase fallback CDN...');
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2';
            script.onload = () => console.log('Supabase fallback CDN loaded successfully');
            script.onerror = () => {
                console.error('All Supabase CDNs failed, loading mock version');
                loadMockSupabase();
            };
            document.head.appendChild(script);
        }
        
        // Mock Supabase for testing when CDN fails
        function loadMockSupabase() {
            console.log('Creating mock Supabase for testing...');
            window.supabase = {
                createClient: (url, key) => {
                    console.log('Mock Supabase client created with URL:', url);
                    return {
                        from: (table) => {
                            console.log('Mock query from table:', table);
                            return {
                                select: (columns) => {
                                    console.log('Mock select columns:', columns);
                                    return {
                                        eq: (col, val) => ({ data: mockItems, error: null }),
                                        or: (condition) => ({ data: mockItems, error: null }),
                                        order: (col, opts) => ({ data: mockItems, error: null })
                                    };
                                }
                            };
                        }
                    };
                }
            };
            
            // Mock data for testing
            window.mockItems = [
                {
                    id: '1',
                    created_at: new Date().toISOString(),
                    contest_number: 0,
                    item_data: {
                        name: 'Test Sword',
                        hero: 'Mak',
                        item_size: 'Medium',
                        rarity: 'gold',
                        cooldown: '5.0',
                        passive_effect: 'Test passive effect',
                        on_use_effects: ['Test on use effect'],
                        image_data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
                    },
                    users: { alias: 'TestUser' }
                },
                {
                    id: '2',
                    created_at: new Date().toISOString(),
                    contest_number: 1,
                    item_data: {
                        name: 'Magic Shield',
                        hero: 'Vanessa',
                        item_size: 'Large',
                        rarity: 'diamond',
                        ammo: '3',
                        passive_effect: 'Blocks incoming damage',
                        image_data: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYPhfDwAChwGA60e6kgAAAABJRU5ErkJggg=='
                    },
                    users: { alias: 'TestCreator' }
                }
            ];
            
            console.log('Mock Supabase setup complete with sample data');
        }
    </script>
    
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    <!-- Navigation -->
    <nav class="top-nav">
        <div class="nav-container">
            <a href="index.html" class="nav-logo">‚öîÔ∏è BazaarGen</a>
            <ul class="nav-menu">
                <li><a href="index.html" class="nav-link">Items</a></li>
                <li><a href="skills.html" class="nav-link">Skills</a></li>
                <li><a href="#" class="nav-link active">Browse</a></li>
                <li><a href="contests.html" class="nav-link">Contests</a></li>
            </ul>
        </div>
    </nav>

    <div class="main-content">
        <!-- Header -->
        <div class="page-header">
            <h1 class="page-title">Community Items Browser</h1>
            <p class="page-subtitle">Discover amazing creations from the BazaarGen community</p>
        </div>

        <!-- Controls -->
        <div class="controls-panel">
            <div class="controls-grid">
                <div class="control-group">
                    <label class="control-label">Sort By</label>
                    <select id="sortBy" class="control-select">
                        <option value="recent">Most Recent</option>
                        <option value="oldest">Oldest First</option>
                        <option value="upvotes">Most Upvotes</option>
                        <option value="upvotes_asc">Least Upvotes</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label">Hero Filter</label>
                    <select id="heroFilter" class="control-select">
                        <option value="">All Heroes</option>
                        <option value="Neutral">Neutral</option>
                        <option value="Mak">Mak</option>
                        <option value="Vanessa">Vanessa</option>
                        <option value="Pyg">Pyg</option>
                        <option value="Dooly">Dooly</option>
                        <option value="Stelle">Stelle</option>
                        <option value="Jules">Jules</option>
                        <option value="Vampire">Vampire</option>
                    </select>
                </div>

                <div class="control-group">
                    <label class="control-label">Search</label>
                    <input type="text" id="searchInput" class="control-input" placeholder="Search items...">
                </div>

                <div class="control-group">
                    <label class="control-label">Contest Filter</label>
                    <select id="contestFilter" class="control-select">
                        <option value="">All Items</option>
                        <option value="0">General Items</option>
                        <option value="1">Contest 1</option>
                        <option value="2">Contest 2</option>
                        <option value="3">Contest 3</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Stats -->
        <div class="stats-bar">
            <div class="stat-item">
                Total Items: <span class="stat-value" id="totalItems">0</span>
            </div>
            <div class="stat-item">
                Showing: <span class="stat-value" id="showingItems">0</span>
            </div>
            <div class="stat-item">
                <span id="loadingText" style="display: none;">Loading...</span>
            </div>
        </div>

        <!-- Debug Panel (will be shown when debugging) -->
        <div id="debugContainer" style="display: none;">
        </div>

        <!-- Messages -->
        <div id="errorMessage" class="error" style="display: none;"></div>
        <div id="loadingMessage" class="loading" style="display: none;">Loading items...</div>
        <div id="noResults" class="no-results" style="display: none;">
            No items found. Try adjusting your filters.
        </div>

        <!-- Items Grid -->
        <div id="itemsGrid" class="items-grid"></div>

        <!-- Load More -->
        <div class="load-more-container">
            <button id="loadMoreBtn" class="btn" style="display: none;">Load More Items</button>
            <div id="endMessage" style="display: none; text-align: center; padding: 20px; color: rgb(201, 175, 133);">
                You've seen all available items!
            </div>
        </div>
    </div>

    <!-- Footer with Debug Toggle -->
    <footer style="background: linear-gradient(135deg, rgb(74, 60, 46) 0%, rgb(89, 72, 51) 100%); border-top: 3px solid rgb(251, 225, 183); margin-top: 40px; padding: 30px 0; text-align: center; box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.3);">
        <div style="max-width: 800px; margin: 0 auto; padding: 0 20px;">
            <div style="color: rgb(251, 225, 183); font-size: 1.5em; font-weight: bold; margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);">
                ‚öîÔ∏è BazaarGen Community Browser ‚öîÔ∏è
            </div>
            <div style="color: rgb(201, 175, 133); font-size: 1em; margin-bottom: 20px; line-height: 1.6;">
                Explore amazing creations from the BazaarGen community. Filter, search, and discover new items!
            </div>
            
            <!-- Debug Toggle Button -->
            <button id="debugToggle" class="debug-toggle" onclick="toggleDebugPanel()" title="Toggle Debug Panel">
                üîß Show Debug Panel
            </button>
            
            <div style="height: 2px; background: linear-gradient(90deg, transparent 0%, rgb(218, 165, 32) 50%, transparent 100%); margin: 20px 0;"></div>
            
            <div style="color: rgb(150, 120, 90); font-size: 0.9em; font-style: italic;">
                ¬© 2025 BazaarGen Community Browser
            </div>
            <div style="color: rgb(150, 120, 90); font-size: 0.9em; margin-top: 8px;">
                Built for The Bazaar community
            </div>
        </div>
    </footer>

    <!-- Debug Panel -->
    <div id="debugPanel" class="debug-panel">
        <div class="debug-header">
            <h4>üîß Debug Information</h4>
            <button class="debug-close" onclick="toggleDebugPanel()">Close</button>
        </div>
        <div id="debugContent" class="debug-content">
            <div>Debug information will appear here...</div>
        </div>
    </div>

    <script>
        // Configuration
        const SUPABASE_URL = 'https://zslsedcfihgwbfljqhod.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpzbHNlZGNmaWhnd2JmbGpxaG9kIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDk4NTEwNzksImV4cCI6MjA2NTQyNzA3OX0.wA23SQZ8PZRambG4RVVWlcxUxdVUz4dNKLQgqY_xR08';

        // Debug state
        let supabase;
        let debugMode = false; // Changed to false by default
        let initializationSteps = [];
        
        function debugLog(step, message, data = null) {
            const timestamp = new Date().toISOString();
            const logEntry = { timestamp, step, message, data };
            initializationSteps.push(logEntry);
            
            if (debugMode) {
                console.log(`üîç [${step}] ${message}`, data || '');
            }
            
            // Update debug display
            updateDebugDisplay();
        }
        
        function updateDebugDisplay() {
            const debugContent = document.getElementById('debugContent');
            if (debugContent) {
                debugContent.innerHTML = initializationSteps.map(step => 
                    `<div><strong>[${step.step}]</strong> ${step.message} ${step.data ? JSON.stringify(step.data) : ''}</div>`
                ).join('');
                
                // Auto-scroll to bottom
                debugContent.scrollTop = debugContent.scrollHeight;
            }
        }

        function toggleDebugPanel() {
            const debugPanel = document.getElementById('debugPanel');
            debugPanel.classList.toggle('show');
            
            // Enable debug mode when panel is shown
            debugMode = debugPanel.classList.contains('show');
        }
        
        function checkSupabaseAvailability() {
            debugLog('STEP 1', 'Checking if window.supabase exists...');
            
            if (typeof window === 'undefined') {
                debugLog('ERROR', 'Window object not available');
                return { available: false, reason: 'Window object not available' };
            }
            
            if (typeof window.supabase === 'undefined') {
                debugLog('ERROR', 'window.supabase is undefined');
                return { available: false, reason: 'Supabase library not loaded from CDN' };
            }
            
            if (typeof window.supabase.createClient !== 'function') {
                debugLog('ERROR', 'window.supabase.createClient is not a function', typeof window.supabase.createClient);
                return { available: false, reason: 'Supabase createClient method not available' };
            }
            
            debugLog('SUCCESS', 'Supabase library is available');
            return { available: true, reason: 'Supabase loaded successfully' };
        }
        
        function initializeSupabase() {
            debugLog('STEP 2', 'Starting Supabase initialization...');
            
            const availability = checkSupabaseAvailability();
            if (!availability.available) {
                debugLog('ERROR', 'Supabase not available', availability.reason);
                showError(`Database connection failed: ${availability.reason}`);
                return false;
            }
            
            try {
                debugLog('STEP 3', 'Creating Supabase client...', { url: SUPABASE_URL });
                
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                
                if (!supabase) {
                    debugLog('ERROR', 'Supabase client creation returned null/undefined');
                    return false;
                }
                
                debugLog('STEP 4', 'Checking Supabase client methods...');
                
                if (typeof supabase.from !== 'function') {
                    debugLog('ERROR', 'Supabase client.from is not a function', typeof supabase.from);
                    return false;
                }
                
                debugLog('SUCCESS', 'Supabase client initialized successfully');
                return true;
                
            } catch (error) {
                debugLog('ERROR', 'Exception during Supabase initialization', error.message);
                showError('Database initialization failed: ' + error.message);
                return false;
            }
        }
        
        async function testSupabaseConnection() {
            debugLog('STEP 5', 'Testing Supabase connection...');
            
            try {
                const testQuery = supabase.from('items').select('id').limit(1);
                debugLog('STEP 6', 'Created test query, executing...');
                
                const { data, error } = await testQuery;
                
                if (error) {
                    debugLog('ERROR', 'Supabase test query failed', error);
                    return { success: false, error: error.message };
                }
                
                debugLog('SUCCESS', 'Supabase connection test successful', { itemCount: data?.length });
                return { success: true, data };
                
            } catch (error) {
                debugLog('ERROR', 'Exception during connection test', error.message);
                return { success: false, error: error.message };
            }
        }

        // State
        let allItems = [];
        let displayedItems = [];
        let currentPage = 0;
        const ITEMS_PER_PAGE = 20;
        const ITEMS_PER_LOAD = 5;
        let isLoading = false;

        // DOM Elements
        const itemsGrid = document.getElementById('itemsGrid');
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const loadingMessage = document.getElementById('loadingMessage');
        const errorMessage = document.getElementById('errorMessage');
        const noResults = document.getElementById('noResults');
        const totalItemsSpan = document.getElementById('totalItems');
        const showingItemsSpan = document.getElementById('showingItems');
        const loadingText = document.getElementById('loadingText');
        const endMessage = document.getElementById('endMessage');

        // Filter elements
        const sortBy = document.getElementById('sortBy');
        const heroFilter = document.getElementById('heroFilter');
        const searchInput = document.getElementById('searchInput');
        const contestFilter = document.getElementById('contestFilter');

        // Initialize with comprehensive checks
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('INIT', 'DOM Content Loaded, starting initialization...');
            
            // Wait for external scripts with multiple retry attempts
            let attempts = 0;
            const maxAttempts = 10;
            const checkInterval = 500; // Check every 500ms
            
            function attemptInitialization() {
                attempts++;
                debugLog('RETRY', `Initialization attempt ${attempts}/${maxAttempts}`);
                
                if (attempts > maxAttempts) {
                    debugLog('ERROR', 'Max initialization attempts reached');
                    showError('Failed to load required libraries after multiple attempts. Please refresh the page or check your internet connection.');
                    return;
                }
                
                if (initializeSupabase()) {
                    debugLog('SUCCESS', 'Initialization successful, proceeding...');
                    
                    // Test connection before proceeding
                    testSupabaseConnection().then(result => {
                        if (result.success) {
                            debugLog('SUCCESS', 'All systems ready, loading items...');
                            setupEventListeners();
                            loadItems();
                        } else {
                            debugLog('ERROR', 'Connection test failed', result.error);
                            showError(`Database connection test failed: ${result.error}`);
                        }
                    });
                } else {
                    debugLog('RETRY', `Attempt ${attempts} failed, retrying in ${checkInterval}ms...`);
                    setTimeout(attemptInitialization, checkInterval);
                }
            }
            
            // Start first attempt
            attemptInitialization();
        });

        function setupEventListeners() {
            sortBy.addEventListener('change', handleFilterChange);
            heroFilter.addEventListener('change', handleFilterChange);
            contestFilter.addEventListener('change', handleFilterChange);
            
            // Debounced search
            let searchTimeout;
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(handleFilterChange, 500);
            });

            loadMoreBtn.addEventListener('click', loadMoreItems);

            // Infinite scroll
            window.addEventListener('scroll', function() {
                if (window.innerHeight + window.scrollY >= document.documentElement.offsetHeight - 200) {
                    if (!isLoading && displayedItems.length < allItems.length) {
                        loadMoreItems();
                    }
                }
            });
        }

        async function loadItems() {
            if (isLoading) return;
            
            isLoading = true;
            showLoading(true);
            hideMessages();

            try {
                debugLog('LOAD', 'Loading ALL items from database (no user data needed)...');
                
                // Query ALL items - completely removed user relationship
                let query = supabase
                    .from('items')
                    .select(`
                        id,
                        created_at,
                        contest_number,
                        item_data
                    `);

                // Apply filters (but not user-based ones)
                const filters = getFilters();
                query = applyFilters(query, filters);
                
                // Apply sorting
                query = applySorting(query, filters.sortBy);

                debugLog('QUERY', 'Executing items query for ALL items (no user data)...');
                const { data, error } = await query;

                if (error) {
                    throw error;
                }

                debugLog('SUCCESS', `Loaded ${data.length} items successfully`);
                debugLog('DATA', 'Sample item data', data[0]);

                allItems = data || [];
                displayedItems = [];
                currentPage = 0;
                
                // Clear the grid before adding new items
                itemsGrid.innerHTML = '';
                debugLog('CLEAR', 'Cleared items grid');
                
                updateStats();
                
                // IMPORTANT: Set isLoading to false BEFORE calling loadMoreItems
                isLoading = false;
                showLoading(false);
                
                // Force load initial items
                debugLog('INITIAL', 'Starting initial item load...');
                loadMoreItems();

            } catch (error) {
                debugLog('ERROR', 'Failed to load items', error.message);
                console.error('Error loading items:', error);
                showError('Failed to load items: ' + error.message);
                isLoading = false;
                showLoading(false);
            }
        }

        function getFilters() {
            return {
                sortBy: sortBy.value,
                hero: heroFilter.value,
                search: searchInput.value.trim(),
                contest: contestFilter.value
            };
        }

        function applyFilters(query, filters) {
            if (filters.hero) {
                query = query.eq('item_data->>hero', filters.hero);
            }

            if (filters.contest !== '') {
                query = query.eq('contest_number', parseInt(filters.contest));
            }

            if (filters.search) {
                query = query.ilike('item_data->>name', `%${filters.search}%`);
            }

            return query;
        }

        function applySorting(query, sortValue) {
            switch (sortValue) {
                case 'recent':
                    return query.order('created_at', { ascending: false });
                case 'oldest':
                    return query.order('created_at', { ascending: true });
                case 'upvotes':
                case 'upvotes_asc':
                    // For now, just sort by creation date since upvotes need complex query
                    return query.order('created_at', { ascending: sortValue === 'upvotes_asc' });
                default:
                    return query.order('created_at', { ascending: false });
            }
        }

        function loadMoreItems() {
            debugLog('RENDER', `Starting loadMoreItems - displayed: ${displayedItems.length}, available: ${allItems.length}`);
            
            if (isLoading || displayedItems.length >= allItems.length) {
                debugLog('RENDER', 'Skipping loadMoreItems - already loading or no more items');
                return;
            }

            const startIndex = displayedItems.length;
            const endIndex = Math.min(startIndex + ITEMS_PER_LOAD, allItems.length);
            const newItems = allItems.slice(startIndex, endIndex);

            debugLog('RENDER', `Rendering ${newItems.length} new items (${startIndex} to ${endIndex-1})`);

            newItems.forEach((item, index) => {
                debugLog('CARD', `Creating card ${startIndex + index}`, {
                    id: item.id,
                    name: item.item_data?.name,
                    hasImage: !!item.item_data?.image_data,
                    hero: item.item_data?.hero,
                    rarity: item.item_data?.rarity
                });

                try {
                    const itemCard = createItemCard(item);
                    if (itemCard) {
                        itemsGrid.appendChild(itemCard);
                        displayedItems.push(item);
                        debugLog('CARD', `Successfully added card to grid for item: ${item.item_data?.name || 'Unnamed'}`);
                    } else {
                        debugLog('ERROR', `createItemCard returned null for item: ${item.id}`);
                    }
                } catch (error) {
                    debugLog('ERROR', `Failed to create card for item ${item.id}`, error.message);
                }
            });

            debugLog('RENDER', `Total displayed items: ${displayedItems.length}, Grid children: ${itemsGrid.children.length}`);

            updateStats();
            updateLoadMoreButton();
            
            // Force a check if we need to load more immediately
            if (displayedItems.length < ITEMS_PER_PAGE && displayedItems.length < allItems.length) {
                debugLog('RENDER', 'Need to load more items to reach minimum page size');
                setTimeout(() => loadMoreItems(), 100);
            }
        }

        // MAIN FIX: Updated createItemCard function to properly render items using generator logic
        function createItemCard(item) {
            debugLog('CREATE', `Creating card for item: ${item.id}`, {
                name: item.item_data?.name,
                hasItemData: !!item.item_data,
                itemDataKeys: item.item_data ? Object.keys(item.item_data) : []
            });

            const itemData = item.item_data || {};
            
            // Validate essential data
            if (!itemData.name && !itemData.hero && !itemData.image_data) {
                debugLog('WARNING', `Item ${item.id} has minimal data, skipping`);
                return null;
            }

            // Convert database format to generator format for compatibility
            const cardData = {
                itemName: itemData.name || 'Unnamed Item',
                hero: itemData.hero || 'Neutral',
                cooldown: itemData.cooldown || '',
                ammo: itemData.ammo || '',
                crit: itemData.crit || '',
                multicast: itemData.multicast || '',
                itemSize: itemData.item_size || 'Medium',
                border: itemData.rarity || 'gold',
                passiveEffect: itemData.passive_effect || '',
                onUseEffects: itemData.on_use_effects || [],
                tags: itemData.tags || [],
                scalingValues: itemData.scaling_values || {},
                imageData: itemData.image_data || '',
                timestamp: item.created_at
            };

            // Create card using the exact same logic as the main generator
            const borderColor = getBorderColor(cardData.border);
            const card = document.createElement("div");
            card.className = "card";

            // Add view and upvote buttons for browser
            const cardControls = document.createElement("div");
            cardControls.className = "card-controls";
            
            const viewBtn = document.createElement("button");
            viewBtn.className = "card-view-btn";
            viewBtn.innerHTML = "üëÅÔ∏è";
            viewBtn.title = "View item details";
            viewBtn.onclick = function() {
                viewItemDetails(item);
            };
            
            const upvoteBtn = document.createElement("button");
            upvoteBtn.className = "card-upvote-btn";
            upvoteBtn.innerHTML = "üëç";
            upvoteBtn.title = "Upvote this item";
            upvoteBtn.onclick = function() {
                upvoteItem(item.id);
            };
            
            cardControls.appendChild(viewBtn);
            cardControls.appendChild(upvoteBtn);
            card.appendChild(cardControls);

            const imageContainer = document.createElement("div");
            imageContainer.className = "image-container";
            imageContainer.style.border = `3px solid ${borderColor}`;

            // Create a clipping wrapper for the uploaded image
            const imageClipWrapper = document.createElement("div");
            imageClipWrapper.className = "image-clip-wrapper";

            if (cardData.imageData) {
                const img = document.createElement("img");
                img.className = "uploaded-image";
                img.src = cardData.imageData;
                img.onerror = function() {
                    debugLog('ERROR', `Failed to load image for item: ${cardData.itemName}`);
                    // Show placeholder or hide image container
                    imageClipWrapper.style.background = '#333';
                    imageClipWrapper.innerHTML = '<div style="color: white; text-align: center; padding: 20px;">Image not available</div>';
                };
                imageClipWrapper.appendChild(img);
            } else {
                imageClipWrapper.style.background = '#333';
                imageClipWrapper.innerHTML = '<div style="color: white; text-align: center; padding: 20px;">No image</div>';
            }
            
            imageContainer.appendChild(imageClipWrapper);

            // Add frame overlay
            const frame = createFrameElement(cardData.border, cardData.itemSize);
            imageContainer.appendChild(frame);

            // Add scaling values if any exist
            const scalingContainer = createScalingValuesContainer(cardData.scalingValues);
            if (scalingContainer.children.length > 0) {
                imageContainer.appendChild(scalingContainer);
            }

            // Create tags container
            const tagsContainer = document.createElement("div");
            tagsContainer.className = "tags-container";

            // Always add item size as first tag
            const itemSizeTag = document.createElement("span");
            itemSizeTag.className = "item-tag";
            itemSizeTag.textContent = cardData.itemSize;
            tagsContainer.appendChild(itemSizeTag);

            // Add additional tags
            cardData.tags.forEach(tagText => {
                if (tagText && tagText.trim()) {
                    const tag = document.createElement("span");
                    tag.className = "item-tag";
                    tag.textContent = tagText.trim();
                    tagsContainer.appendChild(tag);
                }
            });

            const content = document.createElement("div");
            content.className = "card-content";
            content.style.border = `3px solid ${borderColor}`;

            const topSection = document.createElement("div");
            topSection.className = "text-section hero-header";
            topSection.style.borderTop = `2px solid ${borderColor}`;
            topSection.style.borderBottom = `2px solid ${borderColor}`;
            const itemTitle = document.createElement("div");
            itemTitle.className = "item-title";
            itemTitle.textContent = cardData.itemName;
            const heroImg = document.createElement("img");
            heroImg.src = `images/${cardData.hero.toLowerCase()}.png`;
            heroImg.alt = cardData.hero;
            heroImg.onerror = function() {
                this.style.display = 'none'; // Hide if hero image not found
            };
            topSection.appendChild(itemTitle);
            topSection.appendChild(heroImg);
            content.appendChild(topSection);

            let onUseSection = null;
            const effectsContainer = document.createElement("div");

            // Add on use effects
            cardData.onUseEffects.forEach(effect => {
                if (effect && effect.trim()) {
                    const effectLine = document.createElement("div");
                    effectLine.className = "on-use-line";

                    const icon = document.createElement("img");
                    icon.src = "images/use-arrow.png";
                    icon.alt = "-";
                    icon.onerror = function() {
                        this.style.display = 'none';
                    };

                    const text = document.createElement("span");
                    text.innerHTML = processKeywordText(effect);

                    effectLine.appendChild(icon);
                    effectLine.appendChild(text);
                    effectsContainer.appendChild(effectLine);
                }
            });

            // Add multicast if > 1
            if (cardData.multicast && parseInt(cardData.multicast) > 1) {
                const icon = document.createElement("img");
                icon.src = "images/use-arrow.png";
                icon.alt = "-";
                icon.onerror = function() { this.style.display = 'none'; };

                const text = document.createElement("span");
                text.innerHTML = "Multicast: " + cardData.multicast;
                const effectLine = document.createElement("div");
                effectLine.className = "on-use-line";

                effectLine.appendChild(icon);
                effectLine.appendChild(text);
                effectsContainer.appendChild(effectLine);
            }

            // Add crit if present
            if (cardData.crit && cardData.crit.trim()) {
                const critLineHR = document.createElement("hr");
                critLineHR.className = "crit-line-hr";
                effectsContainer.appendChild(critLineHR);

                const text = document.createElement("span");
                text.innerHTML = "Crit Chance: " + processKeywordText("/cr") + cardData.crit + "%";
                const effectLine = document.createElement("div");
                effectLine.className = "crit-line";

                effectLine.appendChild(text);
                effectsContainer.appendChild(effectLine);
            }

            if (effectsContainer.children.length > 0) {
                onUseSection = document.createElement("div");
                onUseSection.className = "text-section on-use-section";
                onUseSection.style.borderTop = `2px solid ${borderColor}`;
                onUseSection.style.borderBottom = `2px solid ${borderColor}`;
                onUseSection.appendChild(effectsContainer);
                content.appendChild(onUseSection);
            }

            // Add passive effect
            if (cardData.passiveEffect && cardData.passiveEffect.trim()) {
                const passiveSection = document.createElement("div");
                passiveSection.className = "text-section";
                passiveSection.style.borderTop = `2px solid ${borderColor}`;
                passiveSection.style.borderBottom = `2px solid ${borderColor}`;
                passiveSection.innerHTML = processKeywordText(cardData.passiveEffect);
                content.appendChild(passiveSection);
            }

            // Add cooldown (only if there are on use effects)
            if (cardData.cooldown && cardData.cooldown.trim() && onUseSection) {
                const cooldownDiv = document.createElement("div");
                cooldownDiv.className = "cooldown-section";
                cooldownDiv.innerHTML = `<span>${cardData.cooldown}</span><span class="sec-text">sec</span>`;
                
                // Add cooldown border overlay
                const cooldownBorder = createCooldownBorderElement(cardData.border);
                cooldownDiv.appendChild(cooldownBorder);
                
                content.appendChild(cooldownDiv);
            }

            // Add ammo
            if (cardData.ammo && cardData.ammo.trim()) {
                const ammoDiv = document.createElement("div");
                ammoDiv.className = "ammo-section";
                ammoDiv.style.border = `3px solid ${borderColor}`;
                
                const ammoImg = document.createElement("img");
                ammoImg.src = "images/ammo.png";
                ammoImg.alt = "Ammo";
                ammoImg.onerror = function() { this.style.display = 'none'; };
                ammoDiv.appendChild(ammoImg);
                
                const ammoText = document.createElement("span");
                ammoText.textContent = cardData.ammo;
                ammoDiv.appendChild(ammoText);
                
                content.appendChild(ammoDiv);
            }

            // Create wrapper and visual content container
            const cardWrapper = document.createElement("div");
            cardWrapper.className = "card-wrapper";
            cardWrapper.appendChild(tagsContainer);
            cardWrapper.appendChild(content);

            // Create the tight visual content container
            const visualContent = document.createElement("div");
            visualContent.className = "card-visual-content";
            visualContent.appendChild(imageContainer);
            visualContent.appendChild(cardWrapper);
            
            card.appendChild(visualContent);

            // Set dimensions and positioning
            setTimeout(() => {
                let widthRatio = 1.0;
                if (cardData.itemSize === "Small") {
                    widthRatio = 0.5;
                } else if (cardData.itemSize === "Large") {
                    widthRatio = 1.5;
                }

                const containerWidth = 150 * widthRatio;
                imageContainer.style.width = containerWidth + "px";

                const img = imageContainer.querySelector('.uploaded-image');
                if (img) {
                    img.style.height = "100%";
                    img.style.width = "auto";
                    img.style.objectFit = "cover";
                    img.style.objectPosition = "center";
                }

                if (onUseSection) {
                    positionElementsRelativeToOnUse(content, onUseSection);
                }
            }, 0);

            debugLog('CARD_COMPLETE', `Completed card creation for ${cardData.itemName}`);
            return card;
        }

        // Helper functions from the main generator
        function getBorderColor(value) {
            switch(value?.toLowerCase()) {
                case 'bronze': return 'rgb(205, 127, 50)';
                case 'silver': return 'silver';
                case 'gold': return 'gold';
                case 'diamond': return 'rgb(185, 242, 255)';
                case 'legendary': return 'rgb(124, 46, 44)';
                default: return 'gold';
            }
        }

        function createFrameElement(quality, size) {
            const sizeMap = { 'Small': 's', 'Medium': 'm', 'Large': 'l' };
            const frameSize = sizeMap[size] || 'm';
            const frameQuality = quality?.toLowerCase() || 'gold';
            
            const frameDiv = document.createElement("div");
            frameDiv.className = "card-frame";
            
            const frameImg = document.createElement("img");
            frameImg.src = `images/frames/${frameQuality}_${frameSize}_frame.png`;
            frameImg.alt = `${quality} ${size} frame`;
            frameImg.onerror = () => { frameDiv.style.display = 'none'; };
            
            frameDiv.appendChild(frameImg);
            return frameDiv;
        }

        function createCooldownBorderElement(quality) {
            const qualityMap = {
                'bronze': 'Bronze', 'silver': 'silver', 'gold': 'gold',
                'diamond': 'diamond', 'legendary': 'Legendary'
            };
            
            const mappedQuality = qualityMap[quality?.toLowerCase()] || 'gold';
            const borderDiv = document.createElement("div");
            borderDiv.className = "cooldown-border";
            borderDiv.style.cssText = `
                position: absolute; top: 50%; left: 50%; width: 130%; height: 130%;
                transform: translate(calc(-50% + 2px), -50%); pointer-events: none; z-index: 0;
                background-image: url('images/cooldown/${mappedQuality}_cooldown.png');
                background-size: 100% 100%; background-repeat: no-repeat; background-position: center;
            `;
            
            return borderDiv;
        }

        function createScalingValuesContainer(scalingData) {
            const container = document.createElement("div");
            container.className = "scaling-values-container";
            
            const scalingTypes = ['heal', 'regen', 'shield', 'damage', 'poison', 'burn'];
            
            scalingTypes.forEach(type => {
                const value = scalingData[type];
                if (value && value.toString().trim()) {
                    const scalingElement = document.createElement("div");
                    scalingElement.className = `scaling-value ${type}`;
                    scalingElement.textContent = value.toString().trim();
                    container.appendChild(scalingElement);
                }
            });
            
            return container;
        }

        function processKeywordText(text) {
            if (!text || typeof text !== 'string') return '';
            
            let processedText = text;
            
            // Process longer patterns first
            processedText = processedText.replace(/\/cd/g, '<img src="images/KeyText/cooldown.png" alt="cooldown" class="keyword-icon">');
            processedText = processedText.replace(/\/cr/g, '<img src="images/KeyText/crit.png" alt="crit" class="keyword-icon">');
            processedText = processedText.replace(/\/he/g, '<img src="images/KeyText/heal.png" alt="heal" class="keyword-icon">');
            processedText = processedText.replace(/\/sh/g, '<img src="images/KeyText/sheild.png" alt="sheild" class="keyword-icon">');
            processedText = processedText.replace(/\/mh/g, '<img src="images/KeyText/maxhealth.png" alt="maxhealth" class="keyword-icon">');
            processedText = processedText.replace(/\/de/g, '<img src="images/KeyText/destroy.png" alt="destroy" class="keyword-icon">');
            
            // Then single-letter patterns
            processedText = processedText.replace(/\/s/g, '<img src="images/KeyText/slow.png" alt="slow" class="keyword-icon">');
            processedText = processedText.replace(/\/h/g, '<img src="images/KeyText/haste.png" alt="haste" class="keyword-icon">');
            processedText = processedText.replace(/\/r/g, '<img src="images/KeyText/regen.png" alt="regen" class="keyword-icon">');
            processedText = processedText.replace(/\/p/g, '<img src="images/KeyText/poison.png" alt="poison" class="keyword-icon">');
            processedText = processedText.replace(/\/b/g, '<img src="images/KeyText/burn.png" alt="burn" class="keyword-icon">');
            processedText = processedText.replace(/\/c/g, '<img src="images/KeyText/charge.png" alt="charge" class="keyword-icon">');
            processedText = processedText.replace(/\/d/g, '<img src="images/KeyText/damage.png" alt="damage" class="keyword-icon">');
            processedText = processedText.replace(/\/f/g, '<img src="images/KeyText/freeze.png" alt="freeze" class="keyword-icon">');
            processedText = processedText.replace(/\/l/g, '<img src="images/KeyText/lifesteal.png" alt="lifesteal" class="keyword-icon">');
            processedText = processedText.replace(/\/v/g, '<img src="images/KeyText/value.png" alt="value" class="keyword-icon">');
            processedText = processedText.replace(/\/t/g, '<img src="images/KeyText/transform.png" alt="transform" class="keyword-icon">');
            
            // Color keywords
            const keywordRules = {
                'slow': 'rgb(203, 159, 110)', 'haste': 'rgb(0, 235, 195)', 'charge': 'rgb(0, 235, 195)',
                'cooldown': 'rgb(0, 235, 195)', 'heal': 'rgb(143, 234, 49)', 'regen': 'rgb(143, 234, 49)',
                'poison': 'rgb(13, 190, 79)', 'burn': 'rgb(253, 146, 63)', 'crit': 'rgb(244, 82, 60)',
                'damage': 'rgb(244, 82, 60)', 'freeze': 'rgb(63, 200, 247)', 'lifesteal': 'rgb(181, 56, 115)',
                'value': 'rgb(244, 208, 33)', 'destroy': 'rgb(198, 44, 66)', 'transform': 'rgb(90, 230, 233)',
                'sheild': 'rgb(245, 208, 33)'
            };
            
            Object.entries(keywordRules).forEach(([keyword, color]) => {
                const regex = new RegExp(`\\b${keyword}\\b`, 'gi');
                processedText = processedText.replace(regex, (match) => {
                    return `<span style="color: ${color}; font-weight: bold;" class="key-text">${match}</span>`;
                });
            });
            
            return processedText;
        }

        function positionElementsRelativeToOnUse(content, onUseSection) {
            content.offsetHeight;
            onUseSection.offsetHeight;
            
            const onUseRelativeTop = onUseSection.offsetTop;
            const onUseHeight = onUseSection.offsetHeight;
            const onUseCenterY = onUseRelativeTop + (onUseHeight / 2);
            
            const cooldownSection = content.querySelector('.cooldown-section');
            const ammoSection = content.querySelector('.ammo-section');
            
            if (cooldownSection) {
                cooldownSection.style.top = `${onUseCenterY - 25}px`;
            }
            
            if (ammoSection) {
                const ammoHeight = ammoSection.offsetHeight;
                ammoSection.style.top = `${onUseCenterY - (ammoHeight / 2)}px`;
            }
        }

        function handleFilterChange() {
            console.log('Filters changed, reloading items...');
            itemsGrid.innerHTML = '';
            loadItems();
        }

        function updateStats() {
            totalItemsSpan.textContent = allItems.length;
            showingItemsSpan.textContent = displayedItems.length;
        }

        function updateLoadMoreButton() {
            if (displayedItems.length >= allItems.length) {
                loadMoreBtn.style.display = 'none';
                endMessage.style.display = displayedItems.length > 0 ? 'block' : 'none';
            } else {
                loadMoreBtn.style.display = displayedItems.length > 0 ? 'block' : 'none';
                endMessage.style.display = 'none';
            }

            if (allItems.length === 0) {
                noResults.style.display = 'block';
            } else {
                noResults.style.display = 'none';
            }
        }

        function showLoading(show) {
            loadingMessage.style.display = show ? 'block' : 'none';
            loadingText.style.display = show ? 'inline' : 'none';
        }

        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.style.display = 'block';
        }

        function hideMessages() {
            errorMessage.style.display = 'none';
            noResults.style.display = 'none';
        }

        // Item actions
        function viewItemDetails(item) {
            const itemData = item.item_data || {};
            const createdDate = new Date(item.created_at).toLocaleDateString();
            
            let details = `Item: ${itemData.name || 'Unnamed'}\n`;
            details += `Hero: ${itemData.hero || 'Unknown'}\n`;
            details += `Size: ${itemData.item_size || 'Unknown'}\n`;
            details += `Rarity: ${itemData.rarity || 'Unknown'}\n`;
            details += `Created: ${createdDate}\n`;
            details += `Contest: ${item.contest_number > 0 ? `Contest ${item.contest_number}` : 'General'}\n`;
            
            if (itemData.cooldown) details += `Cooldown: ${itemData.cooldown}s\n`;
            if (itemData.ammo) details += `Ammo: ${itemData.ammo}\n`;
            if (itemData.crit) details += `Crit: ${itemData.crit}%\n`;
            if (itemData.multicast && parseInt(itemData.multicast) > 1) details += `Multicast: ${itemData.multicast}\n`;
            
            if (itemData.passive_effect) {
                details += `\nPassive Effect:\n${itemData.passive_effect}\n`;
            }
            
            if (itemData.on_use_effects?.length) {
                details += `\nOn Use Effects:\n${itemData.on_use_effects.map(effect => `‚Ä¢ ${effect}`).join('\n')}\n`;
            }
            
            if (itemData.tags?.length) {
                details += `\nTags: ${itemData.tags.join(', ')}\n`;
            }
            
            if (itemData.scaling_values) {
                const scalings = Object.entries(itemData.scaling_values)
                    .filter(([key, value]) => value && value.toString().trim())
                    .map(([key, value]) => `${key}: ${value}`);
                if (scalings.length > 0) {
                    details += `\nScaling Values:\n${scalings.join(', ')}\n`;
                }
            }

            alert(details.trim());
            // TODO: Implement proper modal view
        }

        function upvoteItem(itemId) {
            // Placeholder for upvote functionality
            alert('Upvote feature coming soon! Please sign in to vote on items.');
        }

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        console.log('BazaarGen Items Browser loaded successfully');
    </script>
</body>
</html>
